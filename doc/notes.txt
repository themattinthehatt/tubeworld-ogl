%-------------------------------------------------------------------------------
% 01/28/2017
- (DONE) make perlin noise in textureCylinderLight grayscale - change color of
  light to change overall color of tube
- (DONE) threshold intensities so that blobs of color define tube boundaries
- new tubetraveller class - Canyon
- new path-generator class? RandomSmoothedNoise (low-pass filter N(0,1) values;
  how to rescale to maintain some sort of constant stddev for different filters?
- first island - tube development (and guided tour)?
- colliding cirlces governing gaussian blobs resting on top of them; height/std
  determined by frequency
- nighttime island...


%-------------------------------------------------------------------------------
% 01/07/2017
- (DONE) create basic world setup with 2 islands and tubes connecting them
  and 2 sketches per island
- create abstract class for islands; be sure to include
    + final post-processing step (render to a quad/use framebuffers)
    + implement HDR
- island ideas:
    + shape play
        *map perlin noise onto a sphere, threshold, bloom the bright parts
        *do something with normal vectors/geometry shaders?
    + physics (collisions)
    + reaction-diffusion


%-------------------------------------------------------------------------------
% 12/03/16
- (DONE) make cylinder tube option
- (DONE) map images to inside of cylinder
- (DONE) put lighting ball in tube
- dynamically change origin in radial direction
    + user input
    + smoothed random walk
- make grided cylinder tube option in prep for music (send in synthetic power
    spectra first?) - make an abstraction such that a 2D bitmap image can be
    used as a texture on the inside of the cylinder. Features to consider:
    + (DONE) maybe start w/ a single map that gets mapped to all cylinders (a
      nice pattern could look cool)
    + (DONE) different textures get mapped to different cylinders. Start w/
      blank/solid/static textures on all but current cylinder -> play with 
      binary counting?
    + (DONE) move to more dynamic maps; for instance, a single bit flowing down 
      tube to increase the binary number by 1 at some [time interval] -> need to
      figure this out more
        - add a single bit in a random place
        - move to a sandpile model? current map is rgb, pixels with random rgb
          values flow down pipe, w/ at least one pixel value > some threshold
          (to ensure bright, visible pixels) as soon as a pixel surpases white, 
          it unloads its rgb values (clip at 1?) to 2 neighboring pixels (random
          redistribution?)
- with increasing amplitude in a bin/freq band:
    + change height of square
    + change color
    + change opacity (0 amp = clear)

%-------------------------------------------------------------------------------
% 08/19/2016
-(DONE) Instancing
-(DONE) Infinite generation
Once these are done I can fly through space infinitely!!!
(- camera - begin to use it in different ways
    - free mode
    - tethered to user (which should also be an oriented object) (hotkeys 
        for exiting back to free mode)
        - this should also have two modes - first person and third person.
            first person you're actually moving through the tubes.
            Third person you are located a fixed distance from the player
            and a fixed angle as well (user able to change?) so that the
            sketch stays static in the screen while moving through different
            parameter combos
    - special functionality (in tubes, always moving forward, but can 
        move radially or circumferentially, etc.))
- to start, make lrud keys dictate movement within the tube, and
    aswd keys move through parameter space (aswd keys set position in
    parameter space, which is used to update x and y values of the
    player (NO! player position should be set, and parameters are updated
    with this info.) The camera then uses these x and y vals to reposition itelf
(- tube movement - different generation mechanisms
    - straight (to begin with)
    - follow a random walk (how to smooth? need to do bezier curves?)
    - **be a physics object orbiting around attractors
        - randomly placed (and obeying their own physics??) would look
            completely different than attractors with masses located
            on a grid that oscillate in mass (itself generated by what?
            random walk through its own parameter space? oscillations?)
            oscillations are probably sufficient for both cases, as I think
            if each object had its own random frequency this would 
            introduce sufficient randomoness in movement to not be
            detectable.
     - for the last two objects, directions are going to have to be 
        calculated ahead of time to accurately render tube curvature
- then - detach camera from player!! Can zoom out and watch the random 
    behavior from a third person point of view (should do this with 
    the straight tube, before mucking about with physics objects and
    complicated tube trajectory calculations. See if the effect is cool enough.
- what started the whole thing: It would be cool to find a sketch with 
    interesting combinations of parameters combos (2 or 3) and replicated
    the sketch many times, once for each set of parameters combos on a 
    lattice. Then you can move around thet space and see all of them at one
    go. BUT - only the parameter combos nearest you are generated, and you
    are free to move around. THEN do the same as before, detach the camera
    from the player. Perhaps use the random walk script from before to 
    generate player movements, or have user do that while camera follows a 
    predefined track, which may or may not be tied to the movement of the user.
- need to abstract the automatic player movement. Make some sort of interface
    common to all so that the movement generator can act with any sort of 
    sketch that is infinitely generated (maybe just restricted to tunnel-like
    sketches for now). Then I can develop the physics movements completely
    separately from vertex generation and camera updates. There should be
    a larger class that coordinates the player updates (which can also be
    user input-driven), content generation and actual camera movements. So,
    player movement should be most important. The camera will inherit these 
    movements (through the tethered mode) and render accordingly. The sketch
    generation should also be abstracted so that the player coordinates from 
    any such sketch can be used as input to content generation (and thus
    indirectly tied to keyboard input, so these should stay as separate as
    possible for now). (player should have a cube and color attributes to
    make visualization easier for debugging purposes (mostly - also probably
    looks cool in its own right)).
- Larger class
    - pointer to key state arrays
    - pointer to sketch (cube array)
    - pointer to player object
        - simiar to camera class, or just a struct? can the player physics
            handle all necessary manipulation of player? Maybe best to have
            player and camera class both be oriented objects; they have the 
            optioni to be manipulated with keyboard input, but it is up to
            the larger application to call their "selfUpdate" method or use
            its own position manipulation methods. The, for example, when 
            ahe camera is tehtered player updates are made somehow, and the
            setCamera method is called rather than Camera.selfUpdate.
    - pointer to player physics (own class? how to do this?)
        - user input
        - random walk
        - attractors (also need attractor objects?)

%-------------------------------------------------------------------------------

Player/Camera
    - separate, so that collision detection can be placed on user?
      (can probably be two instantiations of the same class, since
      both will need location, heading, etc; perhaps player can 
      inherit from camera, and add physical appearance data)
    
IO class
    - separate keyboard/mouse inputs from overall IO class structure,
      so that, eg, VR handsets can be used?
      
Game states (use enumerator?)
    - predefined (intro, modules)
    - active
    - paused
    - menu (+paused)
        - map
        - controls
        - other?
        
Portal objects
    - control transition points of tubeworld
    - control of gameplay is transferred to them upon passing through
      their defined space; they then alter the gamestate and load 
      modules
    - keep a dynamic list of portal objects? That way the player can
      move around and we don't have to keep track of every single 
      portal - each portal has a (automatically generated?) list of
      neighbors
      
color channels?
render objects with different resolutions based on dist to cam

Overall organization:
    To ask Matt:
        - use of (non-const) global variables? (camera object?)
        - anything to keep in mind to make this easier to port to VR?
    gol3d
    utymap thing
    google video game file structures or some such thing
    opengl project structures
    
terrain generation
    optimizations:
        quad trees - http://www.shamusyoung.com/twentysidedtale/?p=142
        triangle fans - http://www.shamusyoung.com/twentysidedtale/?p=144
        sending terrain in sections


use std::bitset!!


%-------------------------------------------------------------------------------
tubeworld additions:
backstory (white world, black bubble, slow color death of tubeworld)
    white color explores black space, adds a blue buffer zone
    living sculptures of color are under the creative direction of 
    whatever intelligence lives in the white space
intro (white screen, white pixels peel away and zoom by until most is
    black; camera spins 180, white chunks have split into blue backround 
    and copper pieces spelling tubeworld (in mesh?) with tube going thru
    the o
black silhouttes of shape outlines (DNA, boats) that have the thick
    outlines deep dreamed
watching a screen == moving through pixel space
deep dream/filter distortion: small mirrors placed atop pixels that 
    can redirect their light
infrastructure
    separate camera and player - player has collision detection
    make some places in tubeworld loadable modules (esp if music is involved)
    make it possible to enter some of the structures??
    
    
%-------------------------------------------------------------------------------
Possible tracks:
    Extrawelt - Die Welt ist nicht genug
    Dauwd
    Younger Brother
    Einmusik - I.D.C.
